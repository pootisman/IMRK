\documentclass[a4paper, titlepage, 10pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{indentfirst}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{tikz}
\hoffset=-2.1cm
\voffset=-1.6cm
\setlength{\parindent}{1cm}
\textwidth= 16cm
\textheight = 24cm
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\textunderscript}[1]{$_{\text{#1}}$}
\usetikzlibrary{shapes, arrows}
\begin{document}
\include{./title}
\tableofcontents
\newpage
\section{Техническое задание.}
\indent Реализовать программу, производящую имитационое моделирование передачи сигнлов в ридиоканале с множеством приёмников и передатчиков. Вторичной задачей является уменьшение времени работы программы.
\appendix
\section{Описание модели канала.}
При написании программы использовалась модель со следующими праметрами:
\begin{enumerate}
  \item{Зависимость мощности сигнала L от расстоянии расчитывается по следующему уравнению:\\
  \begin{center}
    $
    L = \frac{100*P}{d^5 + a}
    $
  \end{center}
  где P - Мощность передатчика.\\
  d - Расстояние между передатчиком и приёмником.\\
  a - Зачение силы затухания в точке нахождения приёмника.\\}
  \item{Значения переменной а в разных точках определяются матрицей случайных гауссовских величин, корреллированных в пространстве.}
\end{enumerate}

\begin{figure}[h!]
 \begin{center}
  \includegraphics[width=0.7\textwidth]{slow_fading_1.jpg}
  \caption{Отображение примера матрицы значений a в тонах серого.}
 \end{center}
\end{figure}
\addcontentsline{toc}{figure}{Отображение примера матрицы значений a в тонах серого.}

\section{Описание работы программы.}
\indent На вход программе подаются параметры моделирования, такие как:
\begin{enumerate}
 \item{Колчество приёмников и передатчиков.}
 \item{Размер решётки для моделирования, высота/ширина.}
 \item{Использование графического вывода.}
 \item{Использование вывода в файл с указанием названия файла.}
 \item{Ввод из файла приёмников и передатчиков.}
 \item{Запрос краткой справки.}
\end{enumerate}
\indent Генерирование координат источников и передатчиков происходит по равномерному закону распределения. На начальной стадии разработки каждому передатчику сопоставлялся приёмник (абонент). Так, при расчёте проверялось, принадлежит ли абонент данному передатчику. Если принадлежит, то мощность передатчика относилась к сигналу, если абонент не принадлежал передатчику, то мощность относилась к шуму. Результатом моделирования являются уровни отношения сигнал/шум для каждого из абонентов. При генерирования матрицы величин "a" использовалась нереалистичная модель, т.е. некоррелированные гауссовские величины.\\
\section{Проблемы, возникшие при разработке.}
\indent При попытке ускорения работы программы был использован метод параллельных вычислений. Была использована библиотека Posix Threads и OpenMP. При написании первой версии поточной программы не было необходимости в использовании механизмов защиты памяти от "гонок" потоков, так как запись происходила в разные сегменты памяти. Однако, ускорения работы программы не толко не произошло, программа начала работать медленнее. Была рассмотрена возможная причина такого поведения программы, заключавшаяся в конфликте при считывании данных из памяти. Были так же рассмотрены несколько решений данной проблемы:
\begin{enumerate} 
 \item{Выделять дополнительную память для копий конфликтных областей в отдельных потоках, передавая указатели на области памяти в потоки. Данный способ позволил выделить память с разными адресами, однако к желаемому результату это не привело.}
 \item{Выделять память страницами, т.е., получить размер страницы памяти, выделить необходимое кол-во страниц для хранения массива и скопировать массив в данную область. Указатель на выделенную область далее передаётся в поток, к ускорению программы это также не привело.}
\end{enumerate}
\indent В процессе решения данной проблемы я пытался рассмотреть такой аспект как человеческий фактор, т.е. ошибка при программировании распределения потоков. Я воспользовался библиотекой OpenMP, так как задание параметров распараллеливания в ней производится весьма простым методом (при помощи директивы компилятора \#pragma). Но, к сожалению, данная попытка обернулась неудачей. Однако, в результате рассмотрения уже написанного кода и написания нового кода удалось добиться ускорения почти в два раза. Причина ошибки не была чётко установлена, но наиболее вероятным я считаю, что добавление директивы inline перед функциями, использующихся в расчёте модели, привело к такому результату. Далее была добавлена более реалистичная модель расчёта силы сигнала по следующей формуле:
\begin{center}
$
L = 20 \cdot \log_{10}(\frac{4 \cdot \pi}{C/f}) - 2*H_r + 40 \cdot \log_{10}(d)
$
\end{center}
где С - скорость света (распространения сигнала в среде)\\
    f - частота, на которой идёт передача\\
\indent В программе реализован вывод на экран приемников и передатчиков. Красная антенна соответствует передатчику, жёлтая приёмнику, серая линия, соединяющяя их, показывает, какой приёмник соответствует передатчику и наоборот. Рядом с приёмниками и передатчиками выводятся их порядковые номера.\\
\indent Последняя версия программы работает по следующему алгоритму:\\
\begin{enumerate}
 \item{Обработка параметров коммандной строки.}
 \item{Подготовка данных модели, генерирование передатчиков и приёмников, матрицы затуханий.}
 \item{Обсчёт модели, на данном пункте следует заострить внимание. Программа узнаёт сколько рабочих ядер на процессоре используемой машины}
\end{enumerate}
\section{Возможные напрвления развития программы.}
\indent В данный момент происходит переход от графической библиотеки freeglut к библиотеке GLFW. Данное решение основано на добавлении в программу возможности динамического удаления и добавления приёмников и передатчиков. Библиотека freeglut, в свою очередь, не очень удобна при реализации данного механизма. Основным препятствием в данном случае является то, что основной цикл моделирования пришлось-бы внести в цикл отрисовки. Этот шаг весьма сомнителен по той причине, что цикл отрисовки запускаетсяя только при включённой графике, без создания второго цикла в данной ситуации не обойтись. Но, написание второго основного цикла затруднит отладку и чтение кода, что нежелательно. Данный переход может занять длительное время, так-как параллельно производится оптимизация кода.\\
\indent Ниже приведены примеры времени работы программы с потоками и без для разных количеств приёмников и передатчиков. Измерение времени работы производилось при помощи утилиты time.
\begin{figure}[h!]
 \begin{center}
  \includegraphics[width=0.7\textwidth]{plot_sconst.pdf}
  \caption{Время работы программы с постоянным кол-вом. передатчиков.}
 \end{center}
\end{figure}

\addcontentsline{toc}{figure}{Время работы программы с постоянным кол-вом. передатчиков.}
\begin{figure}[h!]
 \begin{center}
  \includegraphics[width=0.7\textwidth]{plot_sdyn.pdf}
  \caption{Время работы программы c кол-вом. передатчиков, равным кол-ву. приёмников.}
 \end{center}
\end{figure}
\addcontentsline{toc}{figure}{Время работы программы c кол-вом. передатчиков, равным кол-ву. приёмников.}
\end{document}
